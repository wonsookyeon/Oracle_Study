-- 2일차

--BEETWEEN 연산자 : 두 값의 범위에 해당하는 데이터만 출력할 때 사용되는 확장 연산자
SELECT *
FROM EMPLOYEES
Where EMPLOYEE_ID >=120 and EMPLOYEE_ID <=130;

SELECT *
FROM EMPLOYEES
Where EMPLOYEE_ID between 120 and 130;  -- 위의 결과 값이 같다.

SELECT *
FROM EMPLOYEES
WHERE SALARY BETWEEN 10000 and 12000;

-- in 연산자 : 여러 개의 값을 지정하여 일치하는 데이터만 출력
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME = 'Steven' OR FIRST_NAME = 'John' OR FIRST_NAME = 'Peter';

SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME in ('Steven', 'John', 'Peter'); -- 위의 결과와 같다.

SELECT *
FROM COUNTRIES
WHERE COUNTRY_ID in ('US','IL','SG');

-- IS NULL : 속성의 값이 null 값인지를 비교하여 데이터 조회
SELECT *
FROM LOCATIONS
WHERE STATE_PROVINCE is null;  -- null값 추출

SELECT *
FROM LOCATIONS
WHERE STATE_PROVINCE is not null; -- null이 아닌 값 추출

-- LIKE 연산자 : 문자열에서 부분적으로 일치하는 것만 출력
-- % : 0개 이상의 문자
-- _ : 1개의 문자

SELECT *
FROM LOCATIONS
WHERE CITY like 'South%'; -- CITY 중 South로 시작하는 레코드만 추출

-- STREET_ADDRESS 열에서 중간 글자가 Vi인 레코드 추출
SELECT *
FROM LOCATIONS
WHERE STREET_ADDRESS like '%Vi%';

SELECT *
FROM LOCATIONS
WHERE city like 'South____'; -- _4개 입력 : South글자로 시작하고 뒷 자리는 4자까지 오는것 추출

--연습문제

-- 1. Jobs 테이블에서 Job_title 기준으로 정렬하여 직업 조회
SELECT JOB_TITLE
FROM JOBS;

-- 2. countries 테이블에서 country_name 기준 내림차순으로 정렬하여 조회
SELECT COUNTRY_NAME
FROM COUNTRIES ORDER BY COUNTRY_NAME DESC;

-- 3. EMPLOYEES 테이블에서 salary 가 10000에서 12000 사이인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE SALARY>=10000 and SALARY<=12000;
-- WHERE SALARY BETWEEN 10000 and 12000;

-- 4. EMPLOYEES 테이블에서 job_id가 'IT_PROG'와 'ST_MAN' 인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG' or JOB_ID = 'ST_MAN';
--WHERE JOB_ID IN ('IT_PROG', 'ST_MAN');

-- 5. EMPLOYEES 테이블에서 manager_id가 NULL인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE MANAGER_ID is NULL;

-- 6. departments 테이블에서 manager_id가 NULL이 아닌 부서 조회
SELECT *
FROM DEPARTMENTS
WHERE MANAGER_ID is not NULL;

-- 7. EMPLOYEES 테이블에서 job_id가 'AD'로 시작하는 직원 조회
SELECT *
FROM EMPLOYEES
WHERE JOB_ID like 'AD%';

-- 8. EMPLOYEES 테이블에서 first_name 에서 'ni'를 포함하는 직원 조회
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME like '%ni%';

-- 집합 연산자 UNION(합집합 : 중복제외)
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 600; -- 1번

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100; -- 2번

-- 1번과 2번을 UNION
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60
UNION
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100;

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID<=160; -- 3번

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID>=140; -- 4번

-- 3번과 4번을 UNION (중복제거)
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID<=160 -- 3번
UNION
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID>=140; -- 4번

-- 3번과 4번을 UNION ALL (중복포함)
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID<=160 -- 3번
UNION ALL
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID>=140; -- 4번

SELECT* 
FROM JOB_HISTORY;

SELECT* 
FROM JOB_HISTORY
WHERE DEPARTMENT_ID <=110; -- 5번

SELECT* 
FROM JOB_HISTORY
WHERE DEPARTMENT_ID >=80; -- 6번

-- 5,6번 UNION (중복제거)
SELECT* 
FROM JOB_HISTORY
WHERE DEPARTMENT_ID <=110 -- 5번
UNION all
SELECT* 
FROM JOB_HISTORY
WHERE DEPARTMENT_ID >=80; -- 6번